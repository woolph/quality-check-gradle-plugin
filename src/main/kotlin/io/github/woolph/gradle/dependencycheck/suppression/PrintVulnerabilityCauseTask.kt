/* Copyright 2023 ENGEL Austria GmbH */
package io.github.woolph.gradle.dependencycheck.suppression

import io.github.woolph.gradle.util.children
import io.github.woolph.gradle.util.get
import io.github.woolph.gradle.util.processXml
import org.gradle.api.DefaultTask
import org.gradle.api.artifacts.ResolvedConfiguration
import org.gradle.api.artifacts.ResolvedDependency
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.TaskAction

abstract class PrintVulnerabilityCauseTask : DefaultTask() {
    @get:InputFile
    abstract val dependencyCheckXmlReport: RegularFileProperty

    init {
        dependencyCheckXmlReport.convention(
            project.layout.buildDirectory.file("reports/dependency-check-junit.xml"),
        )
    }

    data class VulnerabilityCause(
        val moduleString: String,
        val vulnerabilities: List<Vulnerability>,
    )

    @TaskAction
    fun generateSuppressionFile() {
        val dependencyCauses = project.configurations.getByName("runtimeClasspath").resolvedConfiguration.getDependencyCause()
            .mapKeys { it.key.module.toString() }

        val vulnerabilities = dependencyCheckXmlReport.asFile.get().processXml { doc ->
            doc.children().flatMap { testsuites ->
                testsuites.children().filter {
                    (it.attributes["failures"]?.value?.toInt() ?: 0) > 0
                }.children().mapNotNull { testcase ->
                    testcase.attributes["classname"]?.value?.let { vulnerability ->
                        VulnerabilityCause(
                            testcase.attributes["name"]?.value?.toModuleString() ?: "unknown",
                            listOf(Vulnerability(VulnerabilityType.VulnerabilityName, vulnerability)), // TODO determine correct VulnerabilityType
                        )
                    }
                }
            }
        }

        vulnerabilities.forEach {
            val cause = dependencyCauses[it.moduleString] ?: emptySet()
            logger.warn("${cause.map { it.module }} introduced ${it.moduleString} with the ${it.vulnerabilities.map { it.name }}")
        }
    }

    fun ResolvedConfiguration.getDependencyCause(): Map<ResolvedDependency, Set<ResolvedDependency>> {
        return sequence {
            firstLevelModuleDependencies.forEach { causingDependency ->
                causingDependency.children.forEach { addChildren(it, causingDependency) }
            }
        }.groupBy(Pair<ResolvedDependency, ResolvedDependency>::first,Pair<ResolvedDependency, ResolvedDependency>::second)
            .mapValues { it.value.toSet() }
    }

    suspend fun SequenceScope<Pair<ResolvedDependency, ResolvedDependency>>.addChildren(childDependency: ResolvedDependency, causingDependency: ResolvedDependency) {
        yield(childDependency to causingDependency)
        childDependency.children.forEach {
            addChildren(it, causingDependency)
        }
    }
}
